       // 读取传输层头部前4个字节（源端口和目标端口）
        __u32 ports;
        if (bpf_probe_read_kernel(&ports, sizeof(ports), transport_ptr) == 0) {
            src_port = bpf_ntohs((__u16)(ports >> 16));
            dst_port = bpf_ntohs((__u16)(ports & 0xFFFF));
            
            // 如果是TCP协议，解析TCP头部
            if (iph.protocol == IPPROTO_TCP) {
                // 读取TCP头部（从端口后面开始）
                struct tcphdr tcp_hdr;
                if (bpf_probe_read_kernel(&tcp_hdr, sizeof(tcp_hdr), transport_ptr) == 0) {
                    tcp_flags = tcp_hdr.fin | (tcp_hdr.syn << 1) | (tcp_hdr.rst << 2) | (tcp_hdr.psh << 3) | (tcp_hdr.ack << 4) | (tcp_hdr.urg << 5) | (tcp_hdr.ece << 6) | (tcp_hdr.cwr << 7);
                    tcp_seq = bpf_ntohl(tcp_hdr.seq);
                    tcp_ack = bpf_ntohl(tcp_hdr.ack_seq);
                    
                    // 计算TCP数据长度 = IP总长度 - IP头部长度 - TCP头部长度
                    __u16 ip_total_len = bpf_ntohs(iph.tot_len);
                    __u8 tcp_header_len = (tcp_hdr.doff) * 4;  // TCP头部长度（以4字节为单位）
                    if (tcp_header_len >= 20 && tcp_header_len <= 60) {  // TCP头部长度范围检查
                        __u16 ip_header_len = ihl * 4;
                        if (ip_total_len > ip_header_len + tcp_header_len) {
                            tcp_len = ip_total_len - ip_header_len - tcp_header_len;
                        } else {
                            tcp_len = 0;  // 没有数据部分
                        }
                    } else {
                        tcp_len = 0;  // 无效的TCP头部长度
                    }
                }
            } else if (iph.protocol == IPPROTO_UDP) {
                // 如果是UDP协议，解析UDP头部
                struct udphdr udp_hdr;
                if (bpf_probe_read_kernel(&udp_hdr, sizeof(udp_hdr), transport_ptr) == 0) {
                    // UDP长度 = UDP头部中的长度字段 - UDP头部长度(8字节)
                    __u16 udp_total_len = bpf_ntohs(udp_hdr.len);
                    if (udp_total_len >= 8) {  // UDP最小头部长度
                        udp_len = udp_total_len - 8;  // 减去UDP头部长度
                    } else {
                        udp_len = 0;  // 无效的UDP长度
                    }

     if (iph.protocol == IPPROTO_TCP) {
            struct tcphdr tcp_hdr;
            if (bpf_probe_read_kernel(&tcp_hdr, sizeof(tcp_hdr), transport_ptr) == 0) {
                // 使用 tcphdr 的 source/dest 字段，端序转换后得到正确方向
                src_port = bpf_ntohs(tcp_hdr.source);
                dst_port = bpf_ntohs(tcp_hdr.dest);

                tcp_flags = tcp_hdr.fin | (tcp_hdr.syn << 1) | (tcp_hdr.rst << 2) | (tcp_hdr.psh << 3) | (tcp_hdr.ack << 4) | (tcp_hdr.urg << 5) | (tcp_hdr.ece << 6) | (tcp_hdr.cwr << 7);
                tcp_seq = bpf_ntohl(tcp_hdr.seq);
                tcp_ack = bpf_ntohl(tcp_hdr.ack_seq);

                // 计算TCP数据长度 = IP总长度 - IP头部长度 - TCP头部长度
                __u16 ip_total_len = bpf_ntohs(iph.tot_len);
                __u8 tcp_header_len = (tcp_hdr.doff) * 4;  // TCP头部长度（以4字节为单位）
                if (tcp_header_len >= 20 && tcp_header_len <= 60) {  // TCP头部长度范围检查
                    __u16 ip_header_len = ihl * 4;
                    if (ip_total_len > ip_header_len + tcp_header_len) {
                        tcp_len = ip_total_len - ip_header_len - tcp_header_len;
                    } else {
                        tcp_len = 0;  // 没有数据部分
                    }
                } else {
                    tcp_len = 0;  // 无效的TCP头部长度
                }
            }
        } else if (iph.protocol == IPPROTO_UDP) {
            struct udphdr udp_hdr;
            if (bpf_probe_read_kernel(&udp_hdr, sizeof(udp_hdr), transport_ptr) == 0) {
                // 使用 udphdr 的 source/dest 字段，端序转换
                src_port = bpf_ntohs(udp_hdr.source);
                dst_port = bpf_ntohs(udp_hdr.dest);

                // UDP长度 = UDP头部中的长度字段 - UDP头部长度(8字节)
                __u16 udp_total_len = bpf_ntohs(udp_hdr.len);
                if (udp_total_len >= 8) {  // UDP最小头部长度
                    udp_len = udp_total_len - 8;  // 减去UDP头部长度
                } else {
                    udp_len = 0;  // 无效的UDP长度
                }
            }
        }
    }

### 变更点一览（修复端口方向颠倒）

- 将“用32位一次读+位移拆分端口”的做法，改为“直接读取协议头结构的字段”：
  - TCP: 从 `struct tcphdr` 的 `source`、`dest` 字段获取端口并 `bpf_ntohs` 转换
  - UDP: 从 `struct udphdr` 的 `source`、`dest` 字段获取端口并 `bpf_ntohs` 转换
- 保留了原有的 TCP 标志、序列号、ACK、负载长度等解析逻辑；UDP 长度计算保持不变
- 目的：消除小端架构上用 32 位聚合值做移位拆分引发的“源/目的端口颠倒”问题

### 关键代码变化

```244:286:ebpf/netbee.ebpf.c
// 读取传输层头部（优先使用协议头字段解析端口，避免端序拆分歧义）
void *transport_ptr = (void *)(head + transport_offset);
if (iph.protocol == IPPROTO_TCP) {
    struct tcphdr tcp_hdr;
    if (bpf_probe_read_kernel(&tcp_hdr, sizeof(tcp_hdr), transport_ptr) == 0) {
        // 使用 tcphdr 的 source/dest 字段，端序转换后得到正确方向
        src_port = bpf_ntohs(tcp_hdr.source);
        dst_port = bpf_ntohs(tcp_hdr.dest);

        tcp_flags = tcp_hdr.fin | (tcp_hdr.syn << 1) | (tcp_hdr.rst << 2) | (tcp_hdr.psh << 3) | (tcp_hdr.ack << 4) | (tcp_hdr.urg << 5) | (tcp_hdr.ece << 6) | (tcp_hdr.cwr << 7);
        tcp_seq = bpf_ntohl(tcp_hdr.seq);
        tcp_ack = bpf_ntohl(tcp_hdr.ack_seq);

        // 计算TCP数据长度 = IP总长度 - IP头部长度 - TCP头部长度
        __u16 ip_total_len = bpf_ntohs(iph.tot_len);
        __u8 tcp_header_len = (tcp_hdr.doff) * 4;
        if (tcp_header_len >= 20 && tcp_header_len <= 60) {
            __u16 ip_header_len = ihl * 4;
            if (ip_total_len > ip_header_len + tcp_header_len) {
                tcp_len = ip_total_len - ip_header_len - tcp_header_len;
            } else {
                tcp_len = 0;
            }
        } else {
            tcp_len = 0;
        }
    }
} else if (iph.protocol == IPPROTO_UDP) {
    struct udphdr udp_hdr;
    if (bpf_probe_read_kernel(&udp_hdr, sizeof(udp_hdr), transport_ptr) == 0) {
        // 使用 udphdr 的 source/dest 字段，端序转换
        src_port = bpf_ntohs(udp_hdr.source);
        dst_port = bpf_ntohs(udp_hdr.dest);

        // UDP长度 = UDP头部中的长度字段 - UDP头部长度(8字节)
        __u16 udp_total_len = bpf_ntohs(udp_hdr.len);
        if (udp_total_len >= 8) {
            udp_len = udp_total_len - 8;
        } else {
            udp_len = 0;
        }
    }
}
```

对比点（已删除的旧逻辑要点）：
- 旧逻辑先用 `bpf_probe_read_kernel` 读 4 字节到 `__u32 ports`，再用移位取高/低 16 位：
  - `src_port = bpf_ntohs((__u16)(ports >> 16))`
  - `dst_port = bpf_ntohs((__u16)(ports & 0xFFFF))`
- 在小端机器上，这样的“聚合数值+移位拆半”容易与内存字节序不一致，造成源/目的端口被对调

### 影响与预期效果

- Info 中端口方向将与实际方向一致（例：telnet 到 8080，将显示 client_ephemeral_port->8080）
- 对过滤逻辑无破坏（仍使用 `src_port`/`dst_port`）
- 性能影响可忽略（仍然一次读一个头部结构）

请重新生成 eBPF 对象并运行验证，端口方向应已正确。

我会先在代码里查找端口提取与赋值的具体位置，以及可能的方向判断逻辑来源。然后并行确认 Info 字符串的构造是否固定为 SrcPort->DstPort。接着检视 eBPF 中 src/dst 端口赋值是否可能被颠倒或在不同 hook 环节（ingress/egress）存在方向视角差异。

[1 tool called]

结论：是端口解析的字节序/取半字节顺序问题，导致 Info 中端口方向颠倒（显示成 8080->38726）。

原因分析（不改代码，仅说明）:
- 在 `ebpf/netbee.ebpf.c` 里端口提取是这样做的：
  - 先一次性读传输层头部前 4 字节到一个 32 位的 `ports`
  - 然后用位移取高 16 位、低 16 位：
    - `src_port = bpf_ntohs((__u16)(ports >> 16))`
    - `dst_port = bpf_ntohs((__u16)(ports & 0xFFFF))`
- 这个写法隐含了“32 位整型值的高低 16 位对应该按网络序排列”的假设，但在小端架构（x86_64）上，内存布局与数值高低位的对应关系并非“高位在前”，所以“先右移16位取源端口、后取低16位取目的端口”的做法会把半字节顺序搞反。
- 结果就是在小端环境里，源/目的端口被对调，表现为你看到的 8080->38726（应为 38726->8080）。
- 你提供的样例中，SrcIP=10.42.0.92、DstIP=10.42.3.6，包确实是“本机容器发往对端 8080”，因此正确方向应为 “本机临时端口(38726) -> 8080”。当前显示反了，吻合上述问题。

旁证与对比:
- 同仓库下 `ebpf/netbee-http.ebpf.c` 对端口的处理是先读 `struct tcphdr`，再用 `tcph.source`、`tcph.dest` 配合 `bpf_ntohs`，不会碰到这个半字节顺序问题；因此更稳妥。
- IP 地址在该程序中使用 `bpf_ntohl` 后赋值 `e->src_addr/e->dst_addr`，显示正常，说明问题集中在“用 32 位聚合读取 + 数值位移拆分端口”这一点。

建议方向（仅说明，不改代码）:
- 用读取 `struct tcphdr` + `tcph.source`/`tcph.dest` 的方式提取端口（参考 http 版本实现），或
- 若保留 32 位一次读法，则在小端架构上应互换当前的高/低 16 位提取逻辑，或者改为按字节序安全的方式逐字节拷贝后再 `ntohs`。

这就是为什么你在 telnet 8080 时 Info 显示为 8080->38726 的根因。
