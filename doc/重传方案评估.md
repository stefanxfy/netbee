我来分析NetBee是否可以识别TCP重传，并给出实现方案。

## 📋 TCP重传识别分析

### 🔍 **TCP重传的基本原理**

TCP重传是指发送方在等待ACK超时或收到重复ACK时，重新发送之前的数据包。重传包的特征：

1. **序列号相同**：重传包的序列号与之前发送的包相同
2. **时间间隔**：重传包与原始包之间有一定时间间隔
3. **ACK号可能不同**：接收方可能已经发送了新的ACK
4. **重传标志**：某些情况下可能有重传相关的标志位

### 🎯 **NetBee当前的数据结构分析**

让我先分析当前的数据结构是否包含足够的信息：


[2 tools called]

## 📊 **当前数据结构分析**

### ✅ **已有的关键字段**
- `TcpSeq` (uint32): TCP序列号
- `TcpAck` (uint32): TCP确认号  
- `TcpFlags` (uint8): TCP标志位
- `TcpLen` (uint16): TCP数据长度
- `SrcAddr`, `DstAddr`: 源/目标IP地址
- `SrcPort`, `DstPort`: 源/目标端口

### ❌ **缺失的关键字段**
- **时间戳**: 没有精确的时间戳字段
- **连接标识**: 没有唯一的连接标识符
- **重传计数器**: 没有重传次数统计

## 🎯 **TCP重传识别方案**

### **方案1: 基于序列号和时间窗口的检测**

#### **1.1 数据结构扩展**
```go
// 在SoEvent中添加时间戳字段
type SoEvent struct {
    // ... 现有字段
    TimestampNs uint64  // 纳秒级时间戳
    ConnectionId uint32 // 连接标识符 (hash(src_ip, dst_ip, src_port, dst_port))
}

// 新增重传检测器
type RetransmissionDetector struct {
    // 连接状态映射: connectionId -> ConnectionState
    connections map[uint32]*ConnectionState
    mutex       sync.RWMutex
}

type ConnectionState struct {
    LastSeenSeq map[uint32]uint64 // seq -> timestamp
    RetransCount map[uint32]int   // seq -> retrans_count
    LastCleanup uint64            // 上次清理时间
}
```

#### **1.2 检测算法**
```go
func (rd *RetransmissionDetector) DetectRetransmission(event *SoEvent) bool {
    connId := generateConnectionId(event)
    seq := event.TcpSeq
    timestamp := event.TimestampNs
    
    rd.mutex.Lock()
    defer rd.mutex.Unlock()
    
    // 获取或创建连接状态
    conn, exists := rd.connections[connId]
    if !exists {
        conn = &ConnectionState{
            LastSeenSeq: make(map[uint32]uint64),
            RetransCount: make(map[uint32]int),
        }
        rd.connections[connId] = conn
    }
    
    // 检查是否是重传
    if lastSeen, exists := conn.LastSeenSeq[seq]; exists {
        timeDiff := timestamp - lastSeen
        if timeDiff > RETRANS_TIMEOUT_NS { // 例如: 100ms
            conn.RetransCount[seq]++
            return true
        }
    }
    
    // 更新序列号时间戳
    conn.LastSeenSeq[seq] = timestamp
    
    // 定期清理过期数据
    rd.cleanupExpiredData(timestamp)
    
    return false
}
```

### **方案2: 基于内核函数的检测**

#### **2.1 利用内核重传函数**
```c
// 在eBPF程序中添加重传检测
SEC("kprobe/tcp_retransmit_skb")
int handle_tcp_retransmit_skb(struct pt_regs *ctx) {
    // 标记这是一个重传包
    // 可以通过skb的元数据或特殊标志来标识
}

SEC("kprobe/tcp_retransmit_timer")
int handle_tcp_retransmit_timer(struct pt_regs *ctx) {
    // 检测重传定时器触发
}
```

#### **2.2 在现有kprobe中检测**
```c
// 在do_trace_skb函数中添加重传检测
static int do_trace_skb(struct pt_regs *ctx, struct sk_buff *skb, const char *func_name) {
    // ... 现有代码 ...
    
    // 检查是否是重传相关的函数
    bool is_retrans = false;
    if (strcmp(func_name, "tcp_retransmit_skb") == 0 ||
        strcmp(func_name, "tcp_xmit_retransmit_queue") == 0) {
        is_retrans = true;
    }
    
    // 在事件结构中添加重传标志
    e->is_retransmission = is_retrans;
}
```

### **方案3: 混合检测方案（推荐）**

#### **3.1 数据结构设计**
```go
type SoEvent struct {
    // ... 现有字段
    TimestampNs     uint64  // 纳秒级时间戳
    IsRetransmission bool   // 是否检测为重传
    RetransCount    uint8   // 重传次数
    ConnectionId    uint32  // 连接标识符
}

type RetransmissionDetector struct {
    // 基于序列号的检测
    seqTracker *SequenceTracker
    
    // 基于内核函数的检测
    kernelRetransDetector *KernelRetransDetector
    
    // 统计信息
    stats *RetransmissionStats
}
```

#### **3.2 检测流程**
```go
func (rd *RetransmissionDetector) DetectRetransmission(event *SoEvent) *RetransmissionInfo {
    info := &RetransmissionInfo{
        IsRetransmission: false,
        DetectionMethod:  "",
        Confidence:       0.0,
    }
    
    // 方法1: 内核函数检测（高置信度）
    if rd.kernelRetransDetector.IsRetransFunction(event.FuncName) {
        info.IsRetransmission = true
        info.DetectionMethod = "kernel_function"
        info.Confidence = 0.95
        return info
    }
    
    // 方法2: 序列号重复检测（中等置信度）
    if rd.seqTracker.IsDuplicateSequence(event) {
        info.IsRetransmission = true
        info.DetectionMethod = "sequence_duplicate"
        info.Confidence = 0.80
        return info
    }
    
    // 方法3: 时间窗口检测（低置信度）
    if rd.seqTracker.IsRetransByTimeWindow(event) {
        info.IsRetransmission = true
        info.DetectionMethod = "time_window"
        info.Confidence = 0.60
        return info
    }
    
    return info
}
```

## 🎨 **颜色显示方案**

### **重传包的颜色规则**
```go
type RetransmissionColorRule struct{}

func (r *RetransmissionColorRule) Name() string { return "RETRANS" }

func (r *RetransmissionColorRule) ShouldApply(event *core.SoEvent) bool {
    return event.IsRetransmission
}

func (r *RetransmissionColorRule) GetColor() Color { return ColorMagenta }

func (r *RetransmissionColorRule) GetText(event *core.SoEvent) string {
    return fmt.Sprintf("RETRANS(%d)", event.RetransCount)
}
```

### **输出格式示例**
```
Time                 SrcIP           DstIP           Protocol Length SrcMAC            TTL Info                
----                 -----           -----           -------- ------ ------            --- ----                
20:34:16.059         172.26.220.143  183.9.227.146   TCP      44     05:00:00:59:02:28 64  53930->22 PSH,ACK Seq:1992944562 Ack:1649419433 [tcp_retransmit_skb] PID:941682 RETRANS(1)
20:34:16.066         172.26.220.143  183.9.227.146   TCP      44     05:00:00:59:02:28 64  53930->22 PSH,ACK Seq:1992944562 Ack:1649419433 [dev_queue_xmit] PID:941682
```

## 📈 **实现优先级**

### **阶段1: 基础检测（推荐先实现）**
1. **添加时间戳字段**到SoEvent结构
2. **实现基于内核函数的检测**（最简单、最准确）
3. **添加重传颜色规则**

### **阶段2: 增强检测**
1. **实现序列号重复检测**
2. **添加连接状态跟踪**
3. **实现重传统计**

### **阶段3: 高级功能**
1. **重传原因分析**（超时重传 vs 快速重传）
2. **重传性能指标**（重传率、重传延迟）
3. **重传趋势分析**

## 🎯 **推荐实现方案**

**建议采用方案3（混合检测）**，原因：

1. **准确性高**: 结合内核函数检测和序列号分析
2. **性能好**: 内核函数检测开销小
3. **可扩展**: 可以逐步添加更多检测方法
4. **实用性强**: 能够识别大部分重传场景

**实现步骤**：
1. 首先添加时间戳字段和内核函数检测
2. 然后实现序列号重复检测
3. 最后添加颜色显示和统计功能

这样既能快速获得基本功能，又能逐步完善检测能力。